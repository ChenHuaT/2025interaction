// week_11_7_pacman_part6
// 修改自week11_6_pacman_part5
// 小精靈 張嘴
void setup(){
  size(600, 600);
}
int x = 300-15, y = 300-15,dx = 0,dy = 0,dir = 0;
float m = 0, dm=0.05; // 嘴巴大小,嘴巴改變量 diff of m
boolean[][] bean_eaten = new boolean[20][20];
int [][] walls = {
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0，代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0，代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0，代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆  
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0，代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆  
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0，代表沒有牆
  {0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0},//中間都是牆  
  {0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0},//中間都是牆 
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0，代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆  
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0，代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆  
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0，代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆  
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0，代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆  
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0，代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆  
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0，代表沒有牆
};
void draw() {
  background(0);
  boolean canMoveX = true, canMoveY = true;
  for (int i=0; i<20; i++) { // 左手 i 對應 y 座標
    for (int j=0; j<20; j++) { // 右手 j 對應 x 座標
      if ( walls[i][j]==1 ) {
        fill(255); // 白色方塊
        rect(j*30, i*30, 30, 30);
        if ( (j*30 <= x+dx*15 && x+dx*15 <= j*30+30 && i*30 <= y && y <= i*30+30) ) canMoveX = false;
        if ( (j*30 <= x && x <= j*30+30 && i*30 <= y+dy*15 && y+dy*15 <= i*30+30) ) canMoveY = false;
      } else if ( bean_eaten[i][j]==false ) {
        fill(255); // 白色的豆子
        ellipse( j*30 + 15, i*30 + 15, 5, 5);
        if ( dist(x, y, j*30 + 15, i*30 + 15) < 15 ) bean_eaten[i][j] = true;
      }
    }
  }
  fill(255, 255, 0); // 黃色的
  float m0 = dir * PI/2; // 幾個 "半PI" 有幾個 90度
  arc(x,y,30, 30, m0 + m, m0 + PI*2 - m); // 弧度
  if (x+dx >= 15 && x+dx <= 600-15 && canMoveX) x += dx; // 改變座標 (不超過四邊的牆)
  if (y+dy >= 15 && y+dy <= 600-15 && canMoveY) y += dy; // 改變座標 (不超過四邊的牆)
  // 豆子、轉折點座標 ((j*30, i*30 + 1*30)
  if ( ((x-15)%30 == 0) && ((y-15)%30 == 0) ) {
    if (next==2) {dx = -1; dy = 0; dir = 2;} // dir:2 向左 PI
    if (next==0) {dx = +1; dy = 0; dir = 0;} // dir:0 向右 0度
    if (next==3) {dx = 0; dy = -1; dir = 3;} // dir:3 向上 PI*1.5
    if (next==1) {dx = 0; dy = +1; dir = 1;} // dir:1 向下 PI/2
    next = -1; // 沒有要轉動
  }

  if(m>=1 || m<0) dm = -dm; // 正負倒過來
  m += dm;
}
int next = -1;
void keyPressed(){
  if(keyCode==LEFT) next = 2;
  if(keyCode==RIGHT)next = 0; 
  if(keyCode==UP)   next = 3;
  if(keyCode==DOWN) next = 1;
}
